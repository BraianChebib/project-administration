{"version":3,"names":["_helperMemberExpressionToFunctions","require","_helperOptimiseCallExpression","_core","_traverse","assignmentExpression","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","t","exports","environmentVisitor","visitors","skipAllButComputedKey","path","skip","node","computed","context","maybeQueue","get","visitor","Super","state","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","_getPrototypeOfExpression","objectRef","getObjectRef","targetRef","isStatic","isPrivateMethod","file","addHelper","isDerivedConstructor","numericLiteral","_call","args","optional","argsNode","length","isSpreadElement","isIdentifier","argument","isArrayExpression","arrayExpression","call","optionalCallExpression","value","isInStrictMode","destructureSet","buildCodeFrameError","optionalCall","delete","template","expression","ast","specHandlers_old","_get","proto","booleanLiteral","optimiseCall","looseHandlers","Object","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","constructor","opts","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","replace","refToPreserve","traverse","handler","availableHelper","shouldSkip","parentKey","memberExpressionToFunctions","bind","boundGet","default"],"sources":["../src/index.ts"],"sourcesContent":["import type { File, NodePath, Scope } from \"@babel/core\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport { template, types as t } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} = t;\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.environmentVisitor = visitors.environmentVisitor({});\n  // eslint-disable-next-line no-restricted-globals\n  exports.skipAllButComputedKey = function skipAllButComputedKey(\n    path: NodePath<t.Method | t.ClassProperty>,\n  ) {\n    path.skip();\n    if (path.node.computed) {\n      path.context.maybeQueue(path.get(\"key\"));\n    }\n  };\n}\n\nconst visitor = visitors.environmentVisitor<\n  HandlerState<ReplaceState> & ReplaceState\n>({\n  Super(path, state) {\n    const { node, parentPath } = path;\n    if (!parentPath.isMemberExpression({ object: node })) return;\n    state.handle(parentPath);\n  },\n});\n\nconst unshadowSuperBindingVisitor = visitors.environmentVisitor<{\n  refName: string;\n}>({\n  Scopable(path, { refName }) {\n    // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n    const binding = path.scope.getOwnBinding(refName);\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  },\n});\n\ntype SharedState = {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: () => t.Identifier;\n  getSuperRef: () => t.Identifier;\n  // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n  boundGet: HandlerState[\"get\"];\n};\n\ntype Handler = HandlerState<SharedState> & SharedState;\ntype SuperMember = NodePath<\n  t.MemberExpression & {\n    object: t.Super;\n    property: Exclude<t.MemberExpression[\"property\"], t.PrivateName>;\n  }\n>;\n\nconst enum Flags {\n  Prototype = 0b1,\n  Call = 0b10,\n}\n\ninterface SpecHandler\n  extends Pick<\n    Handler,\n    | \"memoise\"\n    | \"get\"\n    | \"set\"\n    | \"destructureSet\"\n    | \"call\"\n    | \"optionalCall\"\n    | \"delete\"\n  > {\n  _get?(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n  ): t.CallExpression;\n  _call?(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n    optional: boolean,\n  ): t.CallExpression | t.OptionalCallExpression;\n  _getPrototypeOfExpression(this: Handler & SpecHandler): t.CallExpression;\n  prop(this: Handler & SpecHandler, superMember: SuperMember): t.Expression;\n}\n\nconst specHandlers: SpecHandler = {\n  memoise(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    count: number,\n  ) {\n    const { scope, node } = superMember;\n    const { computed, property } = node;\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(this: Handler & SpecHandler, superMember: SuperMember) {\n    const { computed, property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral((property as t.Identifier).name);\n  },\n\n  /**\n   * Creates an expression which result is the proto of objectRef.\n   *\n   * @example <caption>isStatic ==