/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/// <reference types="node" />
import type { Context } from 'vm';
import type { LegacyFakeTimers, ModernFakeTimers } from '@jest/fake-timers';
import type { Circus, Config, Global } from '@jest/types';
import type { fn as JestMockFn, mocked as JestMockMocked, spyOn as JestMockSpyOn, ModuleMocker } from 'jest-mock';
export declare type EnvironmentContext = {
    console: Console;
    docblockPragmas: Record<string, string | Array<string>>;
    testPath: Config.Path;
};
export declare type ModuleWrapper = (this: Module['exports'], module: Module, exports: Module['exports'], require: Module['require'], __dirname: string, __filename: Module['filename'], jest?: Jest, ...extraGlobals: Array<Global.Global[keyof Global.Global]>) => unknown;
export declare class JestEnvironment<Timer = unknown> {
    constructor(config: Config.ProjectConfig, context?: EnvironmentContext);
    global: Global.Global;
    fakeTimers: LegacyFakeTimers<Timer> | null;
    fakeTimersModern: ModernFakeTimers | null;
    moduleMocker: ModuleMocker | null;
    getVmContext(): Context | null;
    setup(): Promise<void>;
    teardown(): Promise<void>;
    handleTestEvent?: Circus.EventHandler;
    exportConditions?: () => Array<string>;
}
export declare type Module = NodeModule;
export interface Jest {
    /**
     * Advances all timers by the needed milliseconds so that only the next timeouts/intervals will run.
     * Optionally, you can provide steps, so it will run steps amount of next timeouts/intervals.
     */
    advanceTimersToNextTimer(steps?: number): void;
    /**
     * Disables automatic mocking in the module loader.
     */
    autoMockOff(): Jest;
    /**
     * Enables automatic mocking in the module loader.
     */
    autoMockOn(): Jest;
    /**
     * Clears the mock.calls and mock.instances properties of all mocks.
     * Equivalent to calling .mockClear() on every mocked function.
     */
    clearAllMocks(): Jest;
    /**
     * Removes any pending timers from the timer system. If any timers have been
     * scheduled, they will be cleared and will never have the opportunity to
     * execute in the future.
     */
    clearAllTimers(): void;
    /**
     * Indicates that the module system should never return a mocked version
     * of the specified module, including all of the specified module's
     * dependencies.
     */
    deepUnmock(moduleName: string): Jest;
    /**
     * Disables automatic mocking in the module loader.
     *
     * After this method is called, all `require()`s will return the real
     * versions of each module (rather than a mocked version).
     */
    disableAutomock(): Jest;
    /**
     * When using `babel-jest`, calls to mock will automatically be hoisted to
     * the top of the code block. Use this method if you want to explicitly avoid
     * this behavior.
     */
    doMock(moduleName: string, moduleFactory?: () => unknown, options?: {
        virtual?: boolean;
    }): Jest;
    /**
     * Indicates that the module system should never return a mocked version
     * of the specified module from require() (e.g. that it should always return
     * the real module).
     */
    dontMock(moduleName: string): Jest;
    /**
     * Enables automatic mocking in the module loader.
     */
    enableAutomock(): Jest;
    /**
     * Creates a mock function. Optionally takes a mock implementation.
     */
    fn: typeof JestMockFn;
    /**
     * Given the name of a module, use the automatic mocking system to generate a
     * mocked version of the module for you.
     *
     * This is useful when you want to create a manual mock that extends the
     * automatic mock's behavior.
     *
     * @deprecated Use `jest.createMockFromModule()` instead
     */
    genMockFromModule(moduleName: string): unknown;
    /**
     * Given the name of a module, use the automatic mocking system to generate a
     * mocked version of the module for you.
     *
     * This is useful when you want to create a manual mock that extends the
     * automatic mock's behavior.
     */
    createMockFromModule(moduleName: string): unknown;
    /**
     * Determines if the given function is a mocked function.
     */
    isMockFunction(fn: (...args: Array<any>) => unknown): fn is ReturnType<typeof JestMockFn>;
    /**
     * Mocks a module with an auto-mocked version when it 